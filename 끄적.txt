
spring framework
spring boot

 => 내장톰캣
 => jar or war
	애플리케이션 개발하고 테스트 후 실제 운영 서버에 배포하기 위해 패키징 필요
	==> 웹 어플리케이션인 경우는 war 파일로 패키징 함
	==> jar : 일반 응용 프로그램 
 => 라이브러리 자동 관리(pom.xml)
 => spring framework 와 다르게 설정 자동화

 화면단 결정
=> jsp(default 아님)
=> thymeleaf ( html 확장자를 사용, jsp 유사)(우리는 이걸 화면단으로 쓰기로 함)
=> freemaker, groovy, mushache, ...;

프로젝트 구조
1) 자바파일 => src/main/java/기본패키지/

2) html, css, js => static/

3) templates => thymeleaf 파일

4) aplication.properties => 프로젝트 환경설정
   DB 설정, 서버 포트 변경, 로그 설정, ...;


실행은 *Application.java 들어가서 Run


스프링 부트에서 데이터베이스 연동
1) 스프링 jdbc // 잘 안씀
2) ORM 라이브러리 // 선택
	- Mybatis
	- hibernate // (일단 이걸 씀)

스프링 중요 개념
1. DI(Dependency Injection) : 의존성 주입
 - setter, 생성자를 이용한 객체 생성

==> 스프링 컨테이너가 필요한 객체를 필요한 시점에 주입해줌(IoC)
==> Inversion of Control(제어의 역전) // 지금까지 개발자가 제어하던 의존성 컨트롤을 스프링 컨테이너가 해줌


모든 요청은 컨트롤러에 경로가 있어야 함

스프링에서 직접적으로 파일 링크 불가능
<a href="index.html">index</a> / 이런거 불가능

대신 컨트롤러 경로지정
<a href="/">index</a>

스프링 프레임워크가 관리해주는 자바 클래스 = bean / 커피콩

@GetMapping("/login")
public void login() {
    void 타입 = 요청한 페이지로
}

@PostMapping("/login")
public String loginPost() {
    return "/member/info";
    String 타입 = return 에 써져있는 주소로 넘어감
}

post 는 form태그 있을때. 나머지는 get으로 받는다고 생각하는게 편한듯









Tv tv = new LgTv(); Tv 클래스에 접근가능 LgTv에 접근하는게 아님


데이터 보내기
request.setAttribute("이름", 값) == model.addAttribute("page", page);
Model.addAttribute("이름", 값);
	th:text="${mDto.email}"
RedirectAttributes == path +="?bno="+bno;
	rttr.addAttribute("이름", 보내고싶은 데이터) => 파라메터로 전달 => ${param.*}
	th:text="${param.bno}"
	rttr.addFlashAttribute("이름", 값) => Sesstion을 이용해서 값을 저장 sesstion에 임시로 저장


@Log4j2
@Controller : 컨트롤러 클래스 위에 설정 / 스프링 컨테이너가 해당 클래스의 객체를 생성(new 객체 를 따로 쓸 필요가 없어짐) 알아서 관리해줌 (제어의 역전 IoC)
@RequestMapping : (value = "/경로", method = RequestMethod.GET:방식post, get) / 경로 지정(예전 버전) / 컨트롤러에 달아서 전체경로달음
@GetMapping("/경로") : @RequestMapping 의 GET 간략화
@PostMapping("/경로") : @RequestMapping 의 POST 간략화
@RequestParam(value = "name", defaultValue = "0") int num1 ==> num1 = ("name") / request에서 넘어오는 파라메터의 이름 지정할 때 사용
@ModelAttribute("이름") : Dto 객체 이름 지정
			==  model.addAttribute("page", page); == servlet 에서 forword로 보낼때 쓰던 setAttribute와 같음




##lombok##
@Data
@Builder


##Thymeleaf##
th:text="" 따음표 안에있는 태그는 해석하지 않음
th:utext="" 따음표 안에있는 태그까지 해석함
th:each="dtoList : ${list}" => foreach 구문
시간 표현 th:text="${#temporals.format(dtoList.regTime, 'yyyy-MM-dd hh:mm:ss')}"
th:if="${dtoList.id % 5 == 0}" 조건문 if
<li th:each="dtoList : ${list}" th:text="${dtoList.id % 5 == 0}?${'---------' + dtoList.id}:${dtoList.first}"></li> 사막연산자 가능
th:switch="${state.even}"
th:case="true" switch case도 있음
스크립트에서 Thymeleaf
    <script>
      const result = "[[${result}]]";
    </script>
또는 <script th:inline="javascript">
	const result = [[${result}]]
     </script>
th:href="@{/sample/ex1(id=${dtoList.id})}" => /sample/ex1?id=1 / a태그 get방식으로 데이터 넘김

div th:fragment="header" / 레이아웃 나누기 / 이름정하는거니까 ${}쓰지 않음
th:insert="/fragments/separate :: content" == jsp에서 includ / 나눈 레이아웃 포함시키기
th:replace="/fragments/separate :: header" => insert랑 같은데 replace를 쓴 태그를 없애고 들어옴

layout:fragment="이름" / html 상단에 xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout" layout:decorate="~{/layouts/layout}" 들어가있으면 /layouts/layout 의 layout:fragment="이름" 과 같은 자리에 들어감 

<th:block></th:block> : 의미는 없고 Thymeleaf 템플릿 엔진이 템플릿을 처리하는 동안 구문을 그룹화하고 제어 구조를 나타내기 위해 사용


@Length(min = 2, max = 6)
@Email
@NotEmpty
@NotBlank

